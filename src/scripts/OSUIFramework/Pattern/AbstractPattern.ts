// eslint-disable-next-line @typescript-eslint/no-unused-vars
namespace OSUIFramework.Patterns {
	/**
	 * Defines the Default props and methods for OutSystemsUI Patterns
	 *
	 * @export
	 * @abstract
	 * @class AbstractPattern
	 * @implements {Interface.IPattern}
	 * @template C
	 */
	export abstract class AbstractPattern<C extends AbstractConfiguration> implements Interface.IPattern {
		/**
		 * Pattern configurations (doubling as current state). Extends AbstractConfiguration.
		 *
		 * @private
		 * @type {C}
		 * @memberof AbstractPattern
		 */
		private _configs: C;

		// Gesture Events instance created
		private _gestureEventInstance: SwipeEvents | DragEvents;

		// Holds if any drag or swipe instance was added to this pattern
		private _hasGestureEvents: boolean;

		/**
		 * Indicates if the pattern has been built or not.
		 *
		 * @private
		 * @memberof AbstractPattern
		 */
		private _isBuilt = false;

		/**
		 * Id generated by us, and added to the HTML to uniquely identify a pattern.
		 *
		 * @private
		 * @type {string}
		 * @memberof AbstractPattern
		 */
		private _uniqueId: string;

		/**
		 * Reference for the base HTML of the element of this pattern;
		 *
		 * @protected
		 * @type {HTMLElement}
		 * @memberof AbstractPattern
		 */
		protected _selfElem: HTMLElement; //TODO: change to private

		/**
		 * Id of the widget. This will be the Id that the developer will be using in runtime.
		 *
		 * @protected
		 * @type {string}
		 * @memberof AbstractPattern
		 */
		protected _widgetId: string;

		constructor(uniqueId: string, configs: C) {
			this._uniqueId = uniqueId;
			this._configs = configs;
		}

		/**
		 * Sets the HTML elements, by setting the references and the attributes.
		 *
		 * @private
		 * @memberof AbstractPattern
		 */
		private _setCommonHtmlElements(): void {
			this._selfElem = Helper.Dom.GetElementByUniqueId(this._uniqueId);
			this._widgetId = this._selfElem.closest(GlobalEnum.DataBlocksTag.DataBlock).id;

			if (this._configs.ExtendedClass !== '') {
				Helper.Dom.Styles.ExtendedClass(this._selfElem, '', this._configs.ExtendedClass);
			}
		}

		/**
		 * Unsets the refences to the HTML elements.
		 *
		 * @protected
		 * @memberof AbstractPattern
		 */
		private _unsetCommonHtmlElements(): void {
			this._selfElem = undefined;
		}

		/**
		 * Getter that allows to obtain the accessibility is enabled.
		 *
		 * @readonly
		 * @protected
		 * @type {boolean}
		 * @memberof AbstractPattern
		 */
		//TODO: getter to remove.
		protected get _enableAccessibility(): boolean {
			return Helper.DeviceInfo.HasAccessibilityEnabled;
		}

		/**
		 * Getter that allows to obtain the self element.
		 *
		 * @readonly
		 * @protected
		 * @type {(HTMLElement | undefined)}
		 * @memberof AbstractPattern
		 */
		public get selfElement(): HTMLElement {
			return this._selfElem;
		}

		/**
		 * Getter that tells if the pattern is already built.
		 *
		 * @readonly
		 * @type {boolean}
		 * @memberof AbstractPattern
		 */
		public get isBuilt(): boolean {
			return this._isBuilt;
		}

		/**
		 * Current configurations/state of the pattern.
		 *
		 * @readonly
		 * @type {C}
		 * @memberof AbstractPattern
		 */
		public get configs(): C {
			return this._configs;
		}

		/**
		 * Get if a gesture event was added
		 *
		 * @readonly
		 * @type {boolean}
		 * @memberof AbstractPattern
		 */
		public get hasGestureEvents(): boolean {
			return this._hasGestureEvents;
		}

		/**
		 * Get gesture event instance
		 *
		 * @readonly
		 * @type {(DragEvents | SwipeEvents)}
		 * @memberof AbstractPattern
		 */
		public get gestureEventInstance(): DragEvents | SwipeEvents {
			return this._gestureEventInstance;
		}

		/**
		 * Unique id of the pattern. Internal use only.
		 *
		 * @readonly
		 * @type {string}
		 * @memberof AbstractPattern
		 */
		public get uniqueId(): string {
			return this._uniqueId;
		}

		/**
		 * Id of the pattern known by the developer. External use only.
		 *
		 * @readonly
		 * @type {string}
		 * @memberof AbstractPattern
		 */
		public get widgetId(): string {
			return this._widgetId;
		}

		/**
		 * Method that creates a new drag event intance and listeners. This is separated from addSwipeEvents,
		 * so that we can have better typification of the needed callbacks
		 *
		 * @protected
		 * @param {HTMLElement} target
		 * @param {Callbacks.Generic} onStartCallback
		 * @param {Callbacks.Generic} onMoveCallback
		 * @param {Callbacks.Generic} onEndCallback
		 * @memberof AbstractPattern
		 */
		protected addDragEvents(
			target: HTMLElement,
			onStartCallback: Callbacks.Generic,
			onMoveCallback: Callbacks.Generic,
			onEndCallback: Callbacks.Generic
		): void {
			this._gestureEventInstance = new Event.DragEvent(target);
			this._gestureEventInstance.setEvents(
				onStartCallback.bind(this),
				onMoveCallback.bind(this),
				onEndCallback.bind(this)
			);
			this._hasGestureEvents = true;
		}

		/**
		 * Method that creates a new swipe event intance and listeners. This is separated from addDragEvents,
		 * so that we can have better typification of the needed callbacks
		 *
		 * @protected
		 * @param {HTMLElement} target
		 * @param {Callbacks.Generic} swipeDownCallback
		 * @param {Callbacks.Generic} swipeLeftCallback
		 * @param {Callbacks.Generic} swipeRightCallback
		 * @param {Callbacks.Generic} swipeUpCallback
		 * @memberof AbstractPattern
		 */
		protected addSwipeEvents(
			target: HTMLElement,
			swipeDownCallback: Callbacks.Generic,
			swipeLeftCallback: Callbacks.Generic,
			swipeRightCallback: Callbacks.Generic,
			swipeUpCallback: Callbacks.Generic
		): void {
			this._gestureEventInstance = new Event.SwipeEvent(target);
			this._gestureEventInstance.setEvents(
				swipeDownCallback.bind(this),
				swipeLeftCallback.bind(this),
				swipeRightCallback.bind(this),
				swipeUpCallback.bind(this)
			);
			this._hasGestureEvents = true;
		}

		/**
		 * Marks the built as being finished.
		 *
		 * @protected
		 * @memberof AbstractPattern
		 */
		protected finishBuild(): void {
			//In the future we can trigger an initialized event.
			this._isBuilt = true;
		}

		/**
		 * Method that removes any gestureEvents added by addDragEvents or addSwipeEvents
		 *
		 * @protected
		 * @memberof AbstractPattern
		 */
		protected removeGestureEvents(): void {
			if (this._gestureEventInstance !== undefined) {
				this._gestureEventInstance.unsetTouchEvents();
				this._hasGestureEvents = false;
			}
		}

		/**
		 * Builds the pattern.
		 *
		 * @memberof AbstractPattern
		 */
		public build(): void {
			this._setCommonHtmlElements();
		}

		/**
		 * Changes the value of the properties in the configurations and
		 * if changes are to a common property, applies the changes.
		 *
		 * @param {string} propertyName
		 * @param {unknown} propertyValue
		 * @memberof AbstractPattern
		 */
		public changeProperty(propertyName: string, propertyValue: unknown): void {
			if (this._configs.hasOwnProperty(propertyName)) {
				if (this._isBuilt) {
					switch (propertyName) {
						case GlobalEnum.CommonPatternsProperties.ExtendedClass:
							Helper.Dom.Styles.ExtendedClass(
								this._selfElem,
								this._configs.ExtendedClass,
								propertyValue as string
							);
							break;
					}
				}
				//First we used the previous value of the ExtendedClass config.
				//then we update it or any other config.
				//We also need to validate if the property can be changed.
				if (this._configs.validateCanChange(this._isBuilt, propertyName)) {
					//If the property can be changed, we then validate if the default value should be applied or not.
					this._configs[propertyName] = this._configs.validateDefault(propertyName, propertyValue);
				}
			} else {
				throw new Error(`changeProperty - Property '${propertyName}' can't be changed.`);
			}
		}

		/**
		 * Disposes the pattern.
		 *
		 * @memberof AbstractPattern
		 */
		public dispose(): void {
			this._isBuilt = false;
			this._unsetCommonHtmlElements();
			this._configs = undefined;

			if (this._hasGestureEvents && this._gestureEventInstance !== undefined) {
				this.removeGestureEvents();
			}
		}

		/**
		 * Enables to uniquely identify the pattern in all ways.
		 *
		 * @param {string} patternId
		 * @return {*}  {boolean}
		 * @memberof AbstractPattern
		 */
		public equalsToID(patternId: string): boolean {
			return patternId === this._uniqueId || patternId === this._widgetId;
		}

		//TODO: add this to make all patterns implement method.
		//protected abstract setHtmlElements();
		//protected abstract unsetHtmlElements();
		//protected abstract setCallbacks();
		//protected abstract unsetCallbacks();
		//protected abstract setA11YProperties();
	}
}
